---
import fs from "node:fs";
import path from "node:path";
import Layout from "../layouts/Layout.astro";
const base = import.meta.env.BASE_URL;

const episodesDir = path.resolve("data/episodes");
const episodeFiles = fs.existsSync(episodesDir)
  ? fs.readdirSync(episodesDir).filter((file) => file.endsWith(".json"))
  : [];

const episodes = episodeFiles
  .map((file) => {
    const raw = fs.readFileSync(path.join(episodesDir, file), "utf8");
    const parsed = JSON.parse(raw);
    parsed.slug = parsed.slug || parsed.date;
    parsed.id = parsed.id || `episode-${parsed.slug}`;
    return parsed;
  })
  .sort((a, b) => {
    const byDate = String(b.date).localeCompare(String(a.date));
    if (byDate !== 0) return byDate;
    return String(b.slug || "").localeCompare(String(a.slug || ""));
  });
---

<Layout title="Ovi English School | Learn English Through Stories">
  <!-- Hero Section -->
  <section class="hero">
    <div class="hero-content">
      <h1>Learn English Through Stories</h1>
      <p>Immerse yourself in engaging real-world stories. Comprehensible input that fits your busy life.</p>
      <a href="#episodes" class="btn btn-primary">Start Learning</a>
    </div>
  </section>

  <section class="card archive-toolbar" id="episodes">
    <h1>Latest Episodes</h1>
    <div class="archive-sort" role="tablist" aria-label="Sort lessons">
      <button type="button" class="archive-sort-btn is-active" data-sort-btn="newest">Newest</button>
      <button type="button" class="archive-sort-btn" data-sort-btn="popular">Popular</button>
      <button type="button" class="archive-sort-btn" data-sort-btn="culture">Culture/Global</button>
    </div>
  </section>

  <section class="episode-list" id="episodeList">
    {
      episodes.map((episode, index) => {
        // Generate emoji thumbnail based on topic
        const emojis = ['ğŸ“°', 'ğŸ¦', 'ğŸ“±', 'ğŸ¦•', 'ğŸŠ', 'ğŸ’»', 'ğŸ­', 'ğŸš—', 'ğŸ®', 'ğŸŒ', 'ğŸµ', 'ğŸ”¬'];
        const thumbnail = emojis[index % emojis.length];
        
        return (
          <article
            class="card episode-card"
            data-date={episode.date || ""}
            data-slug={episode.slug || ""}
            data-episode-id={episode.id || ""}
            data-category={episode.category || ""}
            data-tags={Array.isArray(episode.tags) ? episode.tags.join("|") : ""}
            data-topic={episode.topic || ""}
            data-source={episode?.source?.name || ""}
          >
            <div class="episode-thumbnail">{thumbnail}</div>
            <div class="episode-content">
              <span class="episode-level badge">Beginner</span>
              <h2>
                <a href={`${base}episodes/${episode.slug}`}>{episode.topic}</a>
              </h2>
              <p class="episode-date">{episode.date ? new Date(episode.date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : ''}</p>
            </div>
          </article>
        )
      })
    }
  </section>
</Layout>

<style>
  .hero {
    background: linear-gradient(135deg, var(--deep-navy) 0%, #2a4a6a 100%);
    color: var(--white);
    padding: 48px 24px;
    text-align: center;
    margin-bottom: 24px;
    border-radius: 0 0 12px 12px;
  }
  
  .hero-content {
    max-width: 600px;
    margin: 0 auto;
  }
  
  .hero h1 {
    font-size: 2.5rem;
    color: var(--white);
    margin-bottom: 16px;
  }
  
  .hero p {
    font-size: 1.25rem;
    opacity: 0.9;
    margin-bottom: 24px;
  }
  
  .btn {
    display: inline-block;
    padding: 12px 24px;
    border-radius: 6px;
    font-weight: 600;
    text-decoration: none;
    transition: all 0.2s ease;
  }
  
  .btn-primary {
    background: var(--soft-gold);
    color: var(--deep-navy);
  }
  
  .btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(201, 169, 98, 0.4);
  }
  
  .episode-card {
    display: flex;
    align-items: flex-start;
    gap: 16px;
    padding: 20px;
  }
  
  .episode-thumbnail {
    width: 64px;
    height: 64px;
    min-width: 64px;
    background: linear-gradient(135deg, var(--muted-teal) 0%, #6ab0b0 100%);
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.75rem;
  }
  
  .episode-content {
    flex: 1;
    min-width: 0;
  }
  
  .episode-content h2 {
    font-size: 1.1rem;
    margin: 8px 0;
    line-height: 1.4;
  }
  
  .episode-content h2 a {
    color: var(--deep-navy);
    text-decoration: none;
  }
  
  .episode-content h2 a:hover {
    color: var(--muted-teal);
  }
  
  .episode-date {
    font-size: 0.85rem;
    color: var(--text-light);
    margin: 0;
  }
  
  .episode-level {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  @media (max-width: 480px) {
    .hero h1 {
      font-size: 1.75rem;
    }
    
    .hero p {
      font-size: 1rem;
    }
    
    .episode-thumbnail {
      width: 48px;
      height: 48px;
      min-width: 48px;
      font-size: 1.25rem;
    }
  }
</style>

<script is:inline>
  const list = document.getElementById("episodeList");
  const sortButtons = [...document.querySelectorAll("[data-sort-btn]")];
  const SORT_KEY = "episode-archive-sort-mode";
  const RATING_PREFIX = "episode-rating-";
  const BEHAVIOR_PREFIX = "episode-behavior-";

  if (list && sortButtons.length > 0) {
    const cards = [...list.querySelectorAll(".episode-card")].map((el, index) => ({
      el,
      index,
      date: String(el.dataset.date || ""),
      slug: String(el.dataset.slug || ""),
      episodeId: String(el.dataset.episodeId || ""),
      category: String(el.dataset.category || "").toLowerCase(),
      tags: String(el.dataset.tags || "").toLowerCase(),
      topic: String(el.dataset.topic || "").toLowerCase(),
      source: String(el.dataset.source || "").toLowerCase(),
    }));

    const getDateValue = (dateString) => {
      const timestamp = Date.parse(dateString);
      return Number.isNaN(timestamp) ? 0 : timestamp;
    };

    const getSavedRating = (episodeId) => {
      if (!episodeId) return 0;
      try {
        const raw = localStorage.getItem(`${RATING_PREFIX}${episodeId}`);
        if (!raw) return 0;
        const parsed = JSON.parse(raw);
        const avg = Number(parsed?.average || 0);
        return Number.isFinite(avg) ? avg : 0;
      } catch (_err) {
        return 0;
      }
    };

    const getBehavior = (episodeId) => {
      if (!episodeId) return {};
      try {
        const raw = localStorage.getItem(`${BEHAVIOR_PREFIX}${episodeId}`);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch (_err) {
        return {};
      }
    };

    const bounded = (value, min = 0, max = 9999) =>
      Math.max(min, Math.min(max, Number(value || 0)));

    const popularityScore = (card) => {
      const rating = getSavedRating(card.episodeId);
      const behavior = getBehavior(card.episodeId);
      const opens = bounded(behavior.opens, 0, 1000);
      const completions = bounded(behavior.completions, 0, 1000);
      const flashcardAdds = bounded(behavior.flashcardAdds, 0, 5000);
      const vocabStarts = bounded(behavior.vocabTestStarts, 0, 1000);
      const vocabCompletes = bounded(behavior.vocabTestCompletions, 0, 1000);
      const readingStarts = bounded(behavior.readingModeStarts, 0, 1000);
      const readingAutoStarts = bounded(behavior.readingAutoStarts, 0, 1000);
      const listeningStarts = bounded(behavior.listeningStarts, 0, 1000);
      const activeSeconds = bounded(behavior.activeSeconds, 0, 1e7);
      const ageMs = Math.max(0, Date.now() - getDateValue(card.date));
      const ageDays = ageMs / (1000 * 60 * 60 * 24);
      const freshness = Math.max(0, 21 - ageDays) * 0.4;

      const ratingScore = rating * 18;
      const completionScore = Math.min(20, completions * 6);
      const flashcardScore = Math.min(16, flashcardAdds * 1.6);
      const vocabScore = Math.min(18, vocabStarts * 2 + vocabCompletes * 3);
      const readingScore = Math.min(10, readingStarts * 2 + readingAutoStarts);
      const listeningScore = Math.min(8, listeningStarts * 2);
      const activeScore = Math.min(14, (activeSeconds / 60) * 2);
      const revisitScore = Math.min(10, Math.max(0, opens - 1) * 2.5);

      return (
        ratingScore
        + completionScore
        + flashcardScore
        + vocabScore
        + readingScore
        + listeningScore
        + activeScore
        + revisitScore
        + freshness
      );
    };

    const countMatches = (text, terms) => {
      const sourceText = String(text || "");
      let score = 0;
      for (const term of terms) {
        const pattern = new RegExp(`\\b${term}\\b`, "gi");
        const matches = sourceText.match(pattern);
        if (matches) score += matches.length;
      }
      return score;
    };

    const CULTURE_TERMS = [
      "culture", "cultural", "tradition", "traditional", "festival", "ritual",
      "food", "cuisine", "travel", "heritage", "history", "language", "art", "music"
    ];
    const GLOBAL_TERMS = [
      "global", "world", "worldwide", "international", "japan", "korea", "india", "brazil",
      "mexico", "china", "africa", "europe", "asia", "latin", "turkey", "thailand", "italy"
    ];
    const VIRAL_TERMS = [
      "viral", "trending", "record", "surprising", "shocking", "breakthrough", "breakthroughs"
    ];
    const LOCAL_NICHE_TERMS = [
      "local league", "minor league", "county", "district", "club", "regional"
    ];

    const cultureScore = (card) => {
      const text = `${card.category} ${card.tags} ${card.topic} ${card.source}`;
      const cultureHits = countMatches(text, CULTURE_TERMS);
      const globalHits = countMatches(text, GLOBAL_TERMS);
      const viralHits = countMatches(text, VIRAL_TERMS);
      const localNicheHits = countMatches(text, LOCAL_NICHE_TERMS);
      const categoryBonus =
        card.category === "lifestyle" ? 10 :
          card.category === "global" ? 8 :
            card.category === "science" || card.category === "tech" ? 6 : 0;

      return (
        categoryBonus
        + cultureHits * 4
        + globalHits * 3
        + viralHits * 1.5
        - localNicheHits * 4
        + popularityScore(card) * 0.12
      );
    };

    const comparators = {
      newest: (a, b) => {
        const byDate = getDateValue(b.date) - getDateValue(a.date);
        if (byDate !== 0) return byDate;
        const bySlug = b.slug.localeCompare(a.slug);
        if (bySlug !== 0) return bySlug;
        return a.index - b.index;
      },
      popular: (a, b) => {
        const byScore = popularityScore(b) - popularityScore(a);
        if (byScore !== 0) return byScore;
        return comparators.newest(a, b);
      },
      culture: (a, b) => {
        const byCulture = cultureScore(b) - cultureScore(a);
        if (byCulture !== 0) return byCulture;
        return comparators.popular(a, b);
      },
    };

    const setActiveButton = (mode) => {
      sortButtons.forEach((btn) => {
        const active = btn.dataset.sortBtn === mode;
        btn.classList.toggle("is-active", active);
        btn.setAttribute("aria-selected", active ? "true" : "false");
      });
    };

    const render = (mode) => {
      const comparator = comparators[mode] || comparators.newest;
      cards
        .slice()
        .sort(comparator)
        .forEach((card) => list.appendChild(card.el));
      setActiveButton(mode);
      try {
        localStorage.setItem(SORT_KEY, mode);
      } catch (_err) {
        // ignore localStorage failures
      }
    };

    sortButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const mode = btn.dataset.sortBtn || "newest";
        render(mode);
      });
    });

    window.addEventListener("episode-rating-updated", () => {
      const active = sortButtons.find((btn) => btn.classList.contains("is-active"));
      const mode = active?.dataset.sortBtn || "newest";
      if (mode === "popular" || mode === "culture") render(mode);
    });

    window.addEventListener("episode-behavior-updated", () => {
      const active = sortButtons.find((btn) => btn.classList.contains("is-active"));
      const mode = active?.dataset.sortBtn || "newest";
      if (mode === "popular" || mode === "culture") render(mode);
    });

    let initialMode = "newest";
    try {
      const stored = localStorage.getItem(SORT_KEY);
      if (stored === "newest" || stored === "popular" || stored === "culture") initialMode = stored;
    } catch (_err) {
      // ignore localStorage failures
    }
    render(initialMode);
  }
</script>

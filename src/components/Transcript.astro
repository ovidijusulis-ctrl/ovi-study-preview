---
import VocabPopup from "./VocabPopup.jsx";
import InlineQuestion from "./InlineQuestion.jsx";

const { transcript = "", paragraphQuestions = [] } = Astro.props;

const SECTION_MARKERS = [
  "OPENING",
  "VOCABULARY",
  "NEWS STORY",
  "REVIEW",
  "PRACTICE",
  "CLOSING",
];

function normalizeSectionMarkers(text) {
  let normalized = text;

  for (const section of SECTION_MARKERS) {
    const escaped = section.replace(/\s+/g, "\\s+");
    const pattern = new RegExp(`^\\s*(?:\\[\\s*${escaped}\\s*\\]|${escaped})\\s*:?\\s*$`, "gmi");
    normalized = normalized.replace(pattern, `[${section}]`);
  }

  return normalized;
}

function splitTranscriptSections(text) {
  const normalized = normalizeSectionMarkers(text);
  const sections = [];
  const markerRegex = /\[(OPENING|VOCABULARY|NEWS STORY|REVIEW|PRACTICE|CLOSING)\]/g;
  let match;
  let lastIndex = 0;
  let currentName = null;

  while ((match = markerRegex.exec(normalized)) !== null) {
    if (currentName !== null) {
      sections.push({
        name: currentName,
        content: normalized.slice(lastIndex, match.index).trim(),
      });
    }
    currentName = match[1];
    lastIndex = markerRegex.lastIndex;
  }

  if (currentName !== null) {
    sections.push({
      name: currentName,
      content: normalized.slice(lastIndex).trim(),
    });
  }

  if (sections.length === 0 && normalized.trim()) {
    sections.push({ name: "TRANSCRIPT", content: normalized.trim() });
  }

  const order = new Map(SECTION_MARKERS.map((name, index) => [name, index]));
  return sections.sort((a, b) => {
    const aOrder = order.has(a.name) ? order.get(a.name) : 999;
    const bOrder = order.has(b.name) ? order.get(b.name) : 999;
    return aOrder - bOrder;
  });
}

// Build a lookup: paragraphIndex -> question data
const questionMap = new Map();
for (const q of paragraphQuestions) {
  questionMap.set(q.paragraphIndex, q);
}

const sections = splitTranscriptSections(transcript);
const visibleSections = paragraphQuestions.length > 0
  ? sections.filter((section) => !["VOCABULARY", "REVIEW", "PRACTICE"].includes(section.name))
  : sections;
let revealCounter = 0;
---

<section class="card transcript-root" data-transcript-root data-mode="study">
  <h2>Transcript</h2>
  <div class="transcript-controls" data-transcript-controls>
    <div class="transcript-mode-group" role="tablist" aria-label="Transcript mode">
      <button
        type="button"
        class="transcript-mode-btn is-active"
        data-mode-btn="study"
        role="tab"
        aria-selected="true"
      >
        Study Mode
      </button>
      <button
        type="button"
        class="transcript-mode-btn"
        data-mode-btn="listen"
        role="tab"
        aria-selected="false"
      >
        Listen Mode
      </button>
    </div>
    <div class="transcript-reveal-tools">
      <button
        type="button"
        class="transcript-reveal-btn"
        data-reveal-toggle
      >
        Start Step-by-Step Reading
      </button>
      <button
        type="button"
        class="transcript-reveal-next"
        data-reveal-next
        hidden
      >
        Show Next Paragraph
      </button>
    </div>
  </div>
  <p class="transcript-reveal-status" data-reveal-status>
    Reading mode: Full story visible.
  </p>
  <p class="transcript-hint">
    Tap any word you don't know to see its meaning.
  </p>

  {
    visibleSections.map((section) => {
      const paragraphs = section.content
        .split(/\n{2,}/)
        .map((paragraph) => paragraph.trim())
        .filter(Boolean);

      const isNewsStory = section.name === "NEWS STORY";
      const supportsInlineQuestions = isNewsStory || section.name === "TRANSCRIPT";

      return (
        <div class="transcript-section">
          <h3 class="transcript-section-title">{section.name}</h3>
          {supportsInlineQuestions && paragraphs.length > 0 && paragraphQuestions.length === 0 && (
            <p class="muted" style={{ margin: "0 0 10px", fontStyle: "italic" }}>
              Inline comprehension checks are not available for this lesson yet.
            </p>
          )}
          {paragraphs.map((paragraph, pIdx) => {
            const revealIndex = revealCounter;
            revealCounter += 1;

            return (
              <>
                <p class="transcript-paragraph" data-reveal-index={String(revealIndex)}>
                  {paragraph.split(/(\s+)/).map((token) => {
                    if (/^\s+$/.test(token)) return token;

                    const cleaned = token.replace(/[^a-zA-Z'-]/g, "");
                    if (cleaned.length < 2) return token;

                    return (
                      <button
                        type="button"
                        class="transcript-word"
                        data-word={cleaned}
                      >
                        {token}
                      </button>
                    );
                  })}
                </p>
                {supportsInlineQuestions && questionMap.has(pIdx) && (
                  <div class="inline-question-wrap" data-reveal-index={String(revealIndex)}>
                    <InlineQuestion
                      client:load
                      question={questionMap.get(pIdx).question}
                      answer={questionMap.get(pIdx).answer}
                      hint={questionMap.get(pIdx).hint}
                    />
                  </div>
                )}
              </>
            );
          })}
        </div>
      );
    })
  }

  <VocabPopup client:load />
</section>

<script is:inline>
  const root = document.querySelector("[data-transcript-root]");
  if (root) {
    const controls = root.querySelector("[data-transcript-controls]");
    const modeButtons = [...root.querySelectorAll("[data-mode-btn]")];
    const revealToggle = root.querySelector("[data-reveal-toggle]");
    const revealNext = root.querySelector("[data-reveal-next]");
    const revealStatus = root.querySelector("[data-reveal-status]");
    const revealItems = [...root.querySelectorAll("[data-reveal-index]")]
      .sort((a, b) => Number(a.dataset.revealIndex || 0) - Number(b.dataset.revealIndex || 0));

    let mode = "study";
    let revealOn = false;
    let revealCursor = 0;
    const totalSteps = revealItems.length
      ? Math.max(...revealItems.map((item) => Number(item.dataset.revealIndex || 0))) + 1
      : 0;

    const setMode = (nextMode) => {
      mode = nextMode;
      root.dataset.mode = mode;
      modeButtons.forEach((button) => {
        const active = button.dataset.modeBtn === mode;
        button.classList.toggle("is-active", active);
        button.setAttribute("aria-selected", active ? "true" : "false");
      });
      if (mode === "listen") {
        revealOn = false;
      }
      updateRevealUi();
    };

    const updateRevealUi = () => {
      const canReveal = mode === "study" && revealItems.length > 1;
      if (revealToggle) {
        revealToggle.disabled = !canReveal;
        if (!canReveal) {
          revealToggle.textContent = "Step-by-Step Not Available";
        } else if (revealOn) {
          revealToggle.textContent = "Turn Off Step-by-Step";
        } else {
          revealToggle.textContent = "Start Step-by-Step Reading";
        }
      }

      if (!canReveal || !revealOn) {
        revealItems.forEach((item) => {
          item.removeAttribute("data-reveal-hidden");
        });
        if (revealNext) revealNext.hidden = true;
        if (revealStatus) {
          revealStatus.textContent = mode === "listen"
            ? "Listen mode: no word popups or question blocks."
            : "Reading mode: Full story visible.";
        }
        return;
      }

      revealItems.forEach((item) => {
        const idx = Number(item.dataset.revealIndex || 0);
        if (idx <= revealCursor) {
          item.removeAttribute("data-reveal-hidden");
        } else {
          item.setAttribute("data-reveal-hidden", "true");
        }
      });

      const maxIndex = Math.max(...revealItems.map((item) => Number(item.dataset.revealIndex || 0)));
      const completed = revealCursor >= maxIndex;
      if (revealNext) {
        revealNext.hidden = completed;
        revealNext.textContent = `Show Next Paragraph (${Math.min(revealCursor + 2, totalSteps)}/${totalSteps})`;
      }
      if (revealStatus) {
        revealStatus.textContent = completed
          ? `Step-by-step: complete (${totalSteps}/${totalSteps}).`
          : `Step-by-step: paragraph ${Math.min(revealCursor + 1, totalSteps)} of ${totalSteps}.`;
      }
    };

    controls?.addEventListener("click", (event) => {
      const modeBtn = event.target.closest("[data-mode-btn]");
      if (modeBtn) {
        setMode(modeBtn.dataset.modeBtn);
        return;
      }

      if (event.target.closest("[data-reveal-toggle]") && revealToggle && !revealToggle.disabled) {
        revealOn = !revealOn;
        if (revealOn) revealCursor = 0;
        updateRevealUi();
        return;
      }

      if (event.target.closest("[data-reveal-next]") && revealOn) {
        revealCursor += 1;
        updateRevealUi();
      }
    });

    setMode("study");

    root.addEventListener("click", (event) => {
      if (root.dataset.mode === "listen") return;
      const target = event.target.closest("[data-word]");
      if (!target) return;

      const word = target.dataset.word;
      if (!word || word.length < 2) return;

      // Extract sentence context from parent paragraph
      const paragraph = target.closest(".transcript-paragraph");
      let sentence = "";
      if (paragraph) {
        const paraText = paragraph.textContent || "";
        const sentences = paraText.match(/[^.!?]+[.!?]+/g) || [paraText];
        const wordLower = word.toLowerCase();
        sentence = (
          sentences.find((s) => s.toLowerCase().includes(wordLower)) || paraText
        ).trim();
      }

      window.dispatchEvent(
        new CustomEvent("open-vocab-popup", {
          detail: {
            word: word,
            sentence: sentence,
          },
        }),
      );
    });
  }
</script>

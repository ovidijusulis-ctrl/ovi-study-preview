---
import VocabPopup from "./VocabPopup.jsx";
import InlineQuestion from "./InlineQuestion.jsx";

const { transcript = "", paragraphQuestions = [], vocabulary = [] } = Astro.props;

const SECTION_MARKERS = [
  "OPENING",
  "VOCABULARY",
  "NEWS STORY",
  "REVIEW",
  "PRACTICE",
  "CLOSING",
];

function normalizeSectionMarkers(text) {
  let normalized = text;

  for (const section of SECTION_MARKERS) {
    const escaped = section.replace(/\s+/g, "\\s+");
    const pattern = new RegExp(`^\\s*(?:\\[\\s*${escaped}\\s*\\]|${escaped})\\s*:?\\s*$`, "gmi");
    normalized = normalized.replace(pattern, `[${section}]`);
  }

  return normalized;
}

function splitTranscriptSections(text) {
  const normalized = normalizeSectionMarkers(text);
  const sections = [];
  const markerRegex = /\[(OPENING|VOCABULARY|NEWS STORY|REVIEW|PRACTICE|CLOSING)\]/g;
  let match;
  let lastIndex = 0;
  let currentName = null;

  while ((match = markerRegex.exec(normalized)) !== null) {
    if (currentName !== null) {
      sections.push({
        name: currentName,
        content: normalized.slice(lastIndex, match.index).trim(),
      });
    }
    currentName = match[1];
    lastIndex = markerRegex.lastIndex;
  }

  if (currentName !== null) {
    sections.push({
      name: currentName,
      content: normalized.slice(lastIndex).trim(),
    });
  }

  if (sections.length === 0 && normalized.trim()) {
    sections.push({ name: "TRANSCRIPT", content: normalized.trim() });
  }

  const order = new Map(SECTION_MARKERS.map((name, index) => [name, index]));
  return sections.sort((a, b) => {
    const aOrder = order.has(a.name) ? order.get(a.name) : 999;
    const bOrder = order.has(b.name) ? order.get(b.name) : 999;
    return aOrder - bOrder;
  });
}

// Build a lookup: paragraphIndex -> question data
const questionMap = new Map();
for (const q of paragraphQuestions) {
  questionMap.set(q.paragraphIndex, q);
}

const vocabularyMap = new Map();
for (const entry of vocabulary) {
  const key = String(entry?.word || "").trim().toLowerCase();
  if (!key || vocabularyMap.has(key)) continue;
  vocabularyMap.set(key, entry);
}

const sections = splitTranscriptSections(transcript);
const visibleSections = paragraphQuestions.length > 0
  ? sections.filter((section) => !["VOCABULARY", "REVIEW", "PRACTICE"].includes(section.name))
  : sections;
let revealCounter = 0;
---

<section class="card transcript-root" data-transcript-root data-mode="study">
  <h2>Transcript</h2>
  <div class="transcript-controls" data-transcript-controls>
    <div class="transcript-mode-group" role="tablist" aria-label="Transcript mode">
      <button
        type="button"
        class="transcript-mode-btn is-active"
        data-mode-btn="study"
        role="tab"
        aria-selected="true"
      >
        Study Mode
      </button>
      <button
        type="button"
        class="transcript-mode-btn"
        data-mode-btn="listen"
        role="tab"
        aria-selected="false"
      >
        Listen Mode
      </button>
      <button
        type="button"
        class="transcript-mode-btn transcript-guided-start"
        data-guided-start
        aria-pressed="false"
      >
        Reading Mode
      </button>
    </div>
  </div>
  <p class="transcript-reveal-status" data-guided-status>
    Study mode: full transcript visible.
  </p>
  <p class="transcript-hint">
    Tap any word you don't know to see its meaning.
  </p>

  {
    visibleSections.map((section) => {
      const paragraphs = section.content
        .split(/\n{2,}/)
        .map((paragraph) => paragraph.trim())
        .filter(Boolean);

      const isNewsStory = section.name === "NEWS STORY";
      const supportsInlineQuestions = isNewsStory || section.name === "TRANSCRIPT";

      return (
        <div class="transcript-section">
          <h3 class="transcript-section-title">{section.name}</h3>
          {supportsInlineQuestions && paragraphs.length > 0 && paragraphQuestions.length === 0 && (
            <p class="muted" style={{ margin: "0 0 10px", fontStyle: "italic" }}>
              Inline comprehension checks are not available for this lesson yet.
            </p>
          )}
          {paragraphs.map((paragraph, pIdx) => {
            const revealIndex = revealCounter;
            revealCounter += 1;

            return (
              <>
                <p class="transcript-paragraph" data-reveal-index={String(revealIndex)}>
                  {paragraph.split(/(\s+)/).map((token) => {
                    if (/^\s+$/.test(token)) return token;

                    const cleaned = token.replace(/[^a-zA-Z'-]/g, "");
                    if (cleaned.length < 2) return token;
                    const vocabEntry = vocabularyMap.get(cleaned.toLowerCase());

                    return (
                      <button
                        type="button"
                        class="transcript-word"
                        data-word={cleaned}
                        data-definition={vocabEntry?.definition || ""}
                        data-example={vocabEntry?.example || ""}
                        data-context-meaning={vocabEntry?.contextMeaning || ""}
                        data-context-why={vocabEntry?.contextWhy || ""}
                        data-simple-paraphrase={vocabEntry?.simpleParaphrase || ""}
                      >
                        {token}
                      </button>
                    );
                  })}
                </p>
                {supportsInlineQuestions && questionMap.has(pIdx) && (
                  <div class="inline-question-wrap" data-reveal-index={String(revealIndex)}>
                    <InlineQuestion
                      client:load
                      question={questionMap.get(pIdx).question}
                      answer={questionMap.get(pIdx).answer}
                      hint={questionMap.get(pIdx).hint}
                    />
                  </div>
                )}
              </>
            );
          })}
        </div>
      );
    })
  }

  <VocabPopup client:load />

  <div class="transcript-guided-dock" data-guided-dock hidden>
    <div class="transcript-guided-progress" data-guided-progress>
      Part 1/1
    </div>
    <div class="transcript-guided-actions">
      <button type="button" class="transcript-guided-btn" data-guided-next>Next Part</button>
      <button type="button" class="transcript-guided-btn" data-guided-auto>Auto</button>
      <button type="button" class="transcript-guided-btn" data-guided-pause hidden>Pause</button>
      <button type="button" class="transcript-guided-btn" data-guided-reset>Hide Again</button>
      <button type="button" class="transcript-guided-btn" data-guided-reveal-all>Reveal All</button>
      <button type="button" class="transcript-guided-btn transcript-guided-btn-ghost" data-guided-exit>Exit</button>
      <label class="transcript-guided-speed-wrap" for="guided-speed">
        <span>Speed</span>
        <select id="guided-speed" class="transcript-guided-speed" data-guided-speed>
          <option value="6000">6s</option>
          <option value="8000" selected>8s</option>
          <option value="10000">10s</option>
          <option value="12000">12s</option>
        </select>
      </label>
    </div>
  </div>
</section>

<script is:inline>
  const root = document.querySelector("[data-transcript-root]");
  if (root) {
    const controls = root.querySelector("[data-transcript-controls]");
    const modeButtons = [...root.querySelectorAll("[data-mode-btn]")];
    const guidedStart = root.querySelector("[data-guided-start]");
    const guidedStatus = root.querySelector("[data-guided-status]");
    const guidedDock = root.querySelector("[data-guided-dock]");
    const guidedProgress = root.querySelector("[data-guided-progress]");
    const guidedNext = root.querySelector("[data-guided-next]");
    const guidedAuto = root.querySelector("[data-guided-auto]");
    const guidedPause = root.querySelector("[data-guided-pause]");
    const guidedReset = root.querySelector("[data-guided-reset]");
    const guidedRevealAll = root.querySelector("[data-guided-reveal-all]");
    const guidedExit = root.querySelector("[data-guided-exit]");
    const guidedSpeed = root.querySelector("[data-guided-speed]");
    const revealItems = [...root.querySelectorAll("[data-reveal-index]")]
      .sort((a, b) => Number(a.dataset.revealIndex || 0) - Number(b.dataset.revealIndex || 0));

    let mode = "study";
    let guidedOn = false;
    let guidedCursor = 0;
    let autoTimer = null;
    let autoMs = Number(guidedSpeed?.value || 8000);
    const emitBehavior = (metric, amount = 1) => {
      window.dispatchEvent(
        new CustomEvent("episode-behavior", {
          detail: { metric, amount },
        }),
      );
    };
    const stepIndexes = [...new Set(
      revealItems.map((item) => Number(item.dataset.revealIndex || 0))
    )].sort((a, b) => a - b);
    const totalSteps = stepIndexes.length;

    const stopAuto = () => {
      if (autoTimer) {
        window.clearInterval(autoTimer);
        autoTimer = null;
      }
      if (guidedAuto) guidedAuto.hidden = false;
      if (guidedPause) guidedPause.hidden = true;
    };

    const scrollToStep = (index) => {
      const target = root.querySelector(`[data-reveal-index="${index}"]`);
      target?.scrollIntoView({ behavior: "smooth", block: "center" });
    };

    const applyVisibility = () => {
      if (!guidedOn) {
        revealItems.forEach((item) => item.removeAttribute("data-reveal-hidden"));
        return;
      }
      revealItems.forEach((item) => {
        const idx = Number(item.dataset.revealIndex || 0);
        if (idx <= guidedCursor) {
          item.removeAttribute("data-reveal-hidden");
        } else {
          item.setAttribute("data-reveal-hidden", "true");
        }
      });
    };

    const setMode = (nextMode) => {
      mode = nextMode;
      root.dataset.mode = mode;
      modeButtons.forEach((button) => {
        const active = button.dataset.modeBtn === mode;
        button.classList.toggle("is-active", active);
        button.setAttribute("aria-selected", active ? "true" : "false");
      });
      if (mode === "listen") {
        guidedOn = false;
        stopAuto();
        if (guidedDock) {
          guidedDock.hidden = true;
          guidedDock.style.display = "none";
        }
      }
      updateGuidedUi();
    };

    const updateGuidedUi = () => {
      const canGuide = totalSteps > 1;
      if (guidedStart) {
        guidedStart.hidden = false;
        guidedStart.disabled = !canGuide;
        guidedStart.classList.toggle("is-active", guidedOn && canGuide);
        guidedStart.setAttribute("aria-pressed", guidedOn && canGuide ? "true" : "false");
        if (!canGuide) {
          guidedStart.textContent = "Reading Mode Unavailable";
        } else {
          guidedStart.textContent = "Reading Mode";
        }
      }

      if (!canGuide || !guidedOn) {
        root.dataset.guided = "off";
        applyVisibility();
        stopAuto();
        if (guidedDock) {
          guidedDock.hidden = true;
          guidedDock.style.display = "none";
        }
        if (guidedStatus) {
          guidedStatus.hidden = false;
          guidedStatus.textContent = mode === "listen"
            ? "Listen mode: no word popups or inline checks."
            : "Study mode: full transcript visible.";
        }
        return;
      }

      applyVisibility();
      root.dataset.guided = "on";
      if (guidedDock) {
        guidedDock.hidden = false;
        guidedDock.style.removeProperty("display");
      }
      if (guidedStatus) guidedStatus.hidden = false;
      const completed = guidedCursor >= stepIndexes[stepIndexes.length - 1];

      if (guidedNext) {
        guidedNext.disabled = completed;
        guidedNext.textContent = completed ? "Complete" : "Next Part";
      }
      if (guidedProgress) {
        const current = Math.min(guidedCursor + 1, totalSteps);
        guidedProgress.textContent = `Part ${current}/${totalSteps}`;
      }
      if (guidedStatus) {
        guidedStatus.textContent = completed
          ? `Reading mode complete (${totalSteps}/${totalSteps}).`
          : `Reading mode: part ${Math.min(guidedCursor + 1, totalSteps)} of ${totalSteps}.`;
      }
    };

    const advanceGuided = () => {
      const lastIndex = stepIndexes[stepIndexes.length - 1] ?? 0;
      if (guidedCursor >= lastIndex) {
        stopAuto();
        updateGuidedUi();
        return false;
      }
      guidedCursor += 1;
      updateGuidedUi();
      scrollToStep(guidedCursor);
      return true;
    };

    controls?.addEventListener("click", (event) => {
      const modeBtn = event.target.closest("[data-mode-btn]");
      if (modeBtn) {
        setMode(modeBtn.dataset.modeBtn);
        return;
      }

      if (event.target.closest("[data-guided-start]") && guidedStart && !guidedStart.disabled) {
        if (guidedOn) {
          guidedOn = false;
          stopAuto();
          if (guidedDock) {
            guidedDock.hidden = true;
            guidedDock.style.display = "none";
          }
          updateGuidedUi();
          return;
        }

        if (mode === "listen") {
          setMode("study");
        }
        guidedOn = true;
        emitBehavior("readingModeStarts", 1);
        if (guidedOn) {
          guidedCursor = 0;
          scrollToStep(guidedCursor);
        }
        updateGuidedUi();
      }
    });

    guidedNext?.addEventListener("click", () => {
      if (!guidedOn) return;
      advanceGuided();
    });

    guidedAuto?.addEventListener("click", () => {
      if (!guidedOn) {
        guidedOn = true;
        emitBehavior("readingModeStarts", 1);
        guidedCursor = 0;
        scrollToStep(guidedCursor);
      }
      emitBehavior("readingAutoStarts", 1);
      stopAuto();
      autoTimer = window.setInterval(() => {
        const didAdvance = advanceGuided();
        if (!didAdvance) stopAuto();
      }, autoMs);
      guidedAuto.hidden = true;
      if (guidedPause) guidedPause.hidden = false;
      updateGuidedUi();
    });

    guidedPause?.addEventListener("click", () => {
      stopAuto();
      updateGuidedUi();
    });

    guidedReset?.addEventListener("click", () => {
      if (!guidedOn) {
        guidedOn = true;
      }
      stopAuto();
      guidedCursor = 0;
      updateGuidedUi();
      scrollToStep(guidedCursor);
    });

    guidedRevealAll?.addEventListener("click", () => {
      if (!guidedOn) {
        guidedOn = true;
      }
      stopAuto();
      guidedCursor = stepIndexes[stepIndexes.length - 1] ?? 0;
      updateGuidedUi();
      scrollToStep(guidedCursor);
    });

    guidedExit?.addEventListener("click", () => {
      guidedOn = false;
      stopAuto();
      if (guidedDock) {
        guidedDock.hidden = true;
        guidedDock.style.display = "none";
      }
      updateGuidedUi();
    });

    guidedSpeed?.addEventListener("change", () => {
      autoMs = Number(guidedSpeed.value || 8000);
      if (autoTimer) stopAuto();
      updateGuidedUi();
    });

    setMode("study");

    root.addEventListener("click", (event) => {
      if (root.dataset.mode === "listen") return;
      const target = event.target.closest("[data-word]");
      if (!target) return;

      const word = target.dataset.word;
      if (!word || word.length < 2) return;
      const definition = target.dataset.definition || "";
      const example = target.dataset.example || "";
      const contextMeaning = target.dataset.contextMeaning || "";
      const contextWhy = target.dataset.contextWhy || "";
      const simpleParaphrase = target.dataset.simpleParaphrase || "";

      const paragraph = target.closest(".transcript-paragraph");
      let sentence = "";
      if (paragraph) {
        const paraText = paragraph.textContent || "";
        const sentences = paraText.match(/[^.!?]+[.!?]+/g) || [paraText];
        const wordLower = word.toLowerCase();
        sentence = (
          sentences.find((s) => s.toLowerCase().includes(wordLower)) || paraText
        ).trim();
      }

      window.dispatchEvent(
        new CustomEvent("open-vocab-popup", {
          detail: {
            word: word,
            sentence: sentence,
            definition: definition,
            example: example,
            contextMeaning: contextMeaning,
            contextWhy: contextWhy,
            simpleParaphrase: simpleParaphrase,
          },
        }),
      );
    });
  }
</script>
